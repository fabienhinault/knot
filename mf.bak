#lang racket
(require racket/gui)
(require racket/draw)
(require math/matrix)
(require rackunit)

(define (int r) (inexact->exact (round r)))
(define (cycle-left-1 l)
  (append (cdr l) (list (car l))))
(define (cycle-right-1 l)
  (cons (last l) (drop-right l 1)))
(define (cycle-map f l)
  (map f (append (cdr l) (list (car l)))  l ))
(define (cycle-map-minus l)
  (cycle-map - l))
(define (rad-to-deg r)
  (* 180 (/ r pi)))

(define (index-of lst ele)
  (let loop ((lst lst)
             (idx 0))
    (cond ((empty? lst) #f)
          ((equal? (first lst) ele) idx)
          (else (loop (rest lst) (add1 idx))))))

(define (indexes-of lst ele)
  (let loop ((lst lst)
             (idx 0)
             (res '()))
    (cond ((empty? lst) res)
          ((equal? (first lst) ele) (loop (rest lst) (add1 idx) (cons idx res)))
          (else (loop (rest lst) (add1 idx) res)))))

;mf11

;(define z1 100+200i)
;(define z2 300+200i)
;(define z3 200+300i)
;(define z4 200+400i)
;(define knots 
;  (list z1 z2 z3 z4 z2 z1 z4 z3))
;  (list 100+100i 300+100i 300+200i))
;  (list 100+100i 300+100i))

(struct path-node 
  (z chord-left chord-right psi theta phi control-left control-right )
  #:mutable)

(define (path-node-angle pn)
    (+ (angle (path-node-chord-right pn)) 
       (path-node-theta pn)))
 
(define (add-path-node-theta! pn d-theta)
    (set-path-node-theta! pn (+ (path-node-theta pn) d-theta)))

(struct knot-node (z first-path-node second-path-node) #:mutable)

(define (make-cycle . points)
  (define (aux points path knot-nodes)
    (if (null? points)
        (list (reverse path) knot-nodes)
        (let* ((z (car points))
               (pn-found (findf (lambda (pn) (equal? z (path-node-z pn))) path))
               (new-pn  (path-node z '() '() '() '() '() '() '())))
          (aux (cdr points)
               (cons new-pn path)
               (if pn-found 
                   (cons (knot-node z pn-found new-pn) knot-nodes)
                   knot-nodes)))))
  (aux points '() '()))


;(define z1 (knot-node 100+200i '() '()))
;(define z2 (knot-node 200+100i '() '()))
;(define z3 (knot-node 200+300i '() '()))
;(define z4 (knot-node 300+200i '() '()))
;(define z5 (knot-node 400+100i '() '()))
;(define z6 (knot-node 400+300i '() '()))
;(define z7 (knot-node 500+200i '() '()))
;
;(define knot-nodes (list z1 z2 z3 z4 z5 z6 z7))
;
;(define cycle
;  (make-cycle z1 z2 z5 z7 z6 z4 z2 z1 z3 z6 z7 z5 z4 z3))

(define   z1 100+200i )
(define  z2 300+200i )
(define  z3  200+300i)
(define  z4  200+400i )


(match-define (list cycle knot-nodes) (make-cycle z1 z2 z3 z4 z2 z1 z4 z3))



(define (fill-up-chords cycle)
  (let ((chords (map (lambda (pn1 pn2) (- (path-node-z pn2) (path-node-z pn1)))
                     cycle
                     (cycle-left-1 cycle))))
    (map set-path-node-chord-right! cycle chords)
    (map set-path-node-chord-left! cycle (cycle-right-1 chords))))

(fill-up-chords cycle)
(map (lambda (pn)
       (set-path-node-psi! 
        pn
        (angle (/ (path-node-chord-right pn) (path-node-chord-left pn)))))
     cycle)

(define knots (map path-node-z cycle))

(define n (length knots))
(define deltas (cycle-map-minus knots))
(define psis
  (map (lambda (d-k-1-k d-k-k+1) (angle (/ d-k-k+1 d-k-1-k)))
       (cycle-right-1 deltas)
       deltas))
(define (fmod x r)
  (- x (* (round (/ x r)) r)))
(define (mod-angle a)
  (- a (* (round (/ a (* 2 pi))) (* 2 pi))))


;mf116
(define (velocity theta phi)
  (let ((ct (cos theta))
        (st (sin theta))
        (cf (cos phi))
        (sf (sin phi))
        (rt5 (sqrt 5)))
    (min 4.0
         (/ (+ 2.0
               (* (sqrt 2) 
                  (- st (/ sf 16)) 
                  (- sf (/ st 16)) 
                  (- ct cf)))
            (+ 1 
               (* 0.5 (- rt5 1) ct)
               (* 0.5 (- 3 rt5) cf))))))

(define (prev i)
  (modulo (sub1 i) n))
(define (next i)
  (modulo (add1 i) n))

;mf276
(define (A i j)
  (if (not (eq? j (prev i)))
      0
      (/ 1 (magnitude (list-ref deltas j)))))
(define (B+C i j)
  (if (not (eq? i j))
      0
      (+ (/ 2 (magnitude (list-ref deltas (prev i))))
         (/ 2 (magnitude (list-ref deltas i))))))
(define (D i j)
  (if (not (eq? j (next i)))
      0
      (/ 1 (magnitude (list-ref deltas i)))))

(define right
  (build-matrix 
   n 1
   (lambda (i j) 
     (- 0
        (* (/ 2 (magnitude (list-ref deltas (prev i)))) 
           (list-ref psis i))
        (* (/ 1 (magnitude (list-ref deltas i))) 
           (list-ref psis (next i)))))))

(define mat
  (build-matrix n n
                (lambda (i j) (+ (A i j) (B+C i j) (D i j)))))

(define thetas
  (matrix->list (matrix-solve mat right)))

(map set-path-node-theta! cycle thetas)

; modify thetas, so that the curve intersects itself orthogonaly at each point,
; keeping the same bisector
(define (tweak-angles angle1 angle2)
  (let* ((offset (- angle2 angle1))
         (target-offset (+ (/ pi 2) (* (floor (/ offset pi)) pi))))
    (/ (- offset target-offset) 2)))

(check-equal?
 (+ -1.4 (tweak-angles -1.4 1.4))
 (- (/ pi 4)))

(check-equal?
 (+ -1.450515964828205 (tweak-angles -1.450515964828205 1.450515964828205))
 (- (/ pi 4)))

(check-equal?
 (+ 1.4 (tweak-angles 1.4 -1.4))
 (/ pi 4))

(check-equal?
 (< (tweak-angles -0.3345558925337896 3.288158208922769)  0 )
 #true)

(define (knot-node-tweak-thetas kn)
  (let* ((pn1 (knot-node-first-path-node kn))
         (pn2 (knot-node-second-path-node kn))
         (tweak (tweak-angles  (path-node-angle pn1) (path-node-angle pn2))))
    (add-path-node-theta! pn1 (+ tweak))
    (add-path-node-theta! pn2 (- tweak))))

(map knot-node-tweak-thetas knot-nodes)

(set! thetas (map path-node-theta cycle))

(define phis
  (map (lambda (theta psi) (- 0 theta psi))
       thetas
       psis))

(map set-path-node-phi! cycle phis)

(define (right-control-point index)
  (let* ((theta (list-ref thetas index))
         (phi (list-ref phis (next index)))
         (rr (/ (velocity theta phi) 3))
         (st (sin theta))
         (sf (sin phi)))
;    (when (or (and (>= sf 0)
;                   (>= st 0))
;              (and (<= st 0)
;                   (<= sf 0)))
;      (let ((sine (+ (* (abs st) (cos phi)) (* (abs sf) (cos theta)))))
;        (when (and (> sine 0)
;                   (< (abs sf) (* rr sine)))
;          (set! rr (/ (abs sf) sine)))))
    (+ (list-ref knots index)
       (* (list-ref deltas index)
          (make-polar 1 theta)
          rr))))

(define (left-control-point index)
  (let* ((theta (list-ref thetas (prev index)))
         (phi (list-ref phis index))
         (ss (/ (velocity phi theta) 3))
         (st (sin theta))
         (sf (sin phi)))
;    (when (or (and (>= sf 0)
;                   (>= st 0))
;              (and (<= st 0)
;                   (<= sf 0)))
;      (let ((sine (+ (* (abs st) (cos phi)) (* (abs sf) (cos theta)))))
;        (when (and (> sine 0)
;                   (< (abs st) (* ss sine)))
;          (set! ss (/ (abs st) sine)))))
    (- (list-ref knots index)
       (* (list-ref deltas (prev index))
          (make-polar 1 (- phi))
          ss))))




(define z-path%
  (class dc-path%
    (define (z-curve-to z1 z2 z3)
      (send this curve-to
            (real-part z1)
            (imag-part z1)
            (real-part z2)
            (imag-part z2)
            (real-part z3)
            (imag-part z3)))
    (define (z-move-to z)
      (send this move-to
            (real-part z)
            (imag-part z)))
    (public z-curve-to)
    (public z-move-to)
    (super-new)))

(define path (new z-path%))
(send path z-move-to (car knots))
(for ([i (range n)])
  (send path z-curve-to
        (right-control-point i)
        (left-control-point (next i))
        (list-ref knots (next i))))

(define frame (new frame%
                   [label "Example"]
                   [width 500]
                   [height 500]))
(define canvas
  (new canvas% [parent frame]
       [paint-callback
        (lambda (canvas dc)
          (send dc draw-path path))]))

(define (get-path-node kn angle)
  (let* ((pn1 (get-knot-node-first-path-node kn))
	 (theta1 (get-path-node-theta pn1))
	 (pn2 (get-knot-node-second-path-node kn))
	 (theta2 (get-path-node-theta pn2)))
    (if (< (abs (cos (- angle theta1)))
	   (abs (cos (- angle theta2))))
	pn2
	pn1)))

	     

(define (minf l f)
  (define (aux l f val res)
    (if (null? l)
	res
	(let ((valcar (f (car l))))
	  (if (< val valcar)
	      (aux (cdr l) f val res)
	      (aux (cdr l) f valcar (car l))))))
  (aux l f +inf.0 '()))

(define get-nearest-node x y
  (minf knots 
	(lambda (z) (magnitude (- z (make-rectangular x y))))))
(define kg-canvas%
  (class canvas%
     (super-new)
     (define/override (on-event event)
       (let ((event-type (send event get-event-type)))
	 (case event-type
	   ('left-down (set! x (send event get-x))
		       (set! y (send event get-y))
		       (set! node (get-nearest-node x y)))
	   ('left-up
	    (let ((mouse-z (make-rectangular
			    (send event get-x)
			    (send event get-y))))
	      (when (equal? node 
			    (get-nearest-node 
			     (send event get-x)
			     (send event get-y)))
		    (get-path-node node 
				   (angle (- mouse-z
					     (make-rectangular x y))))))))))))
))
