#lang racket
(require racket/gui)
(require racket/draw)
(require math/matrix)
(require rackunit)

(define (changef l pred new)
  (cond ((null? l)'())
        ((pred (car l)) (cons new (cdr l)))
        (else l)))


(define (transpose-lists lists) (apply map list lists))
(define (int r) (inexact->exact (round r)))
(define (cycle-left-1 l)
  (append (cdr l) (list (car l))))
(define left-cycle-1 cycle-left-1)
(define (cycle-right-1 l)
  (cons (last l) (drop-right l 1)))
(define right-cycle-1 cycle-left-1)
(define (cycle-map f l)
  (map f (append (cdr l) (list (car l)))  l ))
(define (cycle-map-minus l)
  (cycle-map - l))
(define (rad-to-deg r)
  (* 180 (/ r pi)))

(define (index-of lst ele)
  (let loop ((lst lst)
             (idx 0))
    (cond ((empty? lst) #f)
          ((equal? (first lst) ele) idx)
          (else (loop (rest lst) (add1 idx))))))

(define (indexes-of lst ele)
  (let loop ((lst lst)
             (idx 0)
             (res '()))
    (cond ((empty? lst) res)
          ((equal? (first lst) ele) (loop (rest lst) (add1 idx) (cons idx res)))
          (else (loop (rest lst) (add1 idx) res)))))

;mf11

;(define z1 100+200i)
;(define z2 300+200i)
;(define z3 200+300i)
;(define z4 200+400i)
;(define knots 
;  (list z1 z2 z3 z4 z2 z1 z4 z3))
;  (list 100+100i 300+100i 300+200i))
;  (list 100+100i 300+100i))

(struct path-node 
  (z chord-left chord-right psi theta phi control-left control-right )
  #:mutable #:transparent)

(define (path-node-angle pn)
    (+ (angle (path-node-chord-right pn)) 
       (path-node-theta pn)))
 
(define (add-path-node-theta! pn d-theta)
    (set-path-node-theta! pn (+ (path-node-theta pn) d-theta)))

(struct knot-node (z first-path-node second-path-node) #:mutable #:transparent)

(struct knot (knot-nodes path-nodes) #:transparent)

(define (make-knot . points)
  (define (aux points path knot-nodes)
    (if (null? points)
        (knot knot-nodes (reverse path))
        (let* ((z (car points))
               (pn-found (findf (lambda (pn) (equal? z (path-node-z pn))) path))
               (new-pn  (path-node z '() '() '() '() '() '() '())))
          (aux (cdr points)
               (cons new-pn path)
               (if pn-found 
                   (cons (knot-node z pn-found new-pn) knot-nodes)
                   knot-nodes)))))
  (aux points '() '()))

(define (turnAngle chord1 chord2)
  (angle (/ chord2 chord1)))

(define (knot-matrix chords)
  ;mf276
  (define (A i j)
    (if (not (eq? j (prev i)))
        0
        (/ 1 (magnitude (list-ref chords j)))))
  (define (B+C i j)
    (if (not (eq? i j))
        0
        (+ (/ 2 (magnitude (list-ref chords (prev i))))
           (/ 2 (magnitude (list-ref chords i))))))
  (define (D i j)
    (if (not (eq? j (next i)))
        0
        (/ 1 (magnitude (list-ref chords i)))))
  (let ((n (length chords)))
    (build-matrix 
     n n
     (lambda (i j) (+ (A i j) (B+C i j) (D i j))))))

(define (knot-right-vector chords turnAngles)
  (build-matrix 
   n 1
   (lambda (i j) 
     (- 0
        (* (/ 2 (magnitude (list-ref chords (prev i)))) 
           (list-ref turnAngles i))
        (* (/ 1 (magnitude (list-ref chords i))) 
           (list-ref turnAngles (next i)))))))

(define (right-control-point point chord theta phi)
  (+ point
     (* chord
        (make-polar 1 theta)
        (/ (velocity theta phi) 3))))

(define (left-control-point point chord theta phi)
  (- point
     (* chord
        (make-polar 1 (- phi))
        (/ (velocity phi theta) 3))))


(define (knot-path . points)
  (let* ((chords (cycle-map-minus points))
         (turnAngles (map turnAngle (cycle-right-1 chords) chords))
         (orig-thetas (matrix->list 
                       (matrix-solve 
                        (knot-matrix chords)
                        (knot-right-vector chords turnAngles))))
         (thetas (knot-tweak-thetas points orig-thetas))
         (phis (map (lambda (theta psi) (- 0 theta psi))
                    thetas
                    turnAngles))
         (z-path (new z-path%)))
    (send z-path z-move-to (car points))
    (map (lambda (zk+ zk+1- zk+1)
           (send z-path z-curve-to zk+ zk+1- zk+1))
         (map right-control-point points thetas (left-cycle-1 phis)
         (left-cycle-1 (map left-control-point points (right-cycle-1 thetas) phis))
         (left-cycle-1 points)))
    z-path))

(define (knot-tweak-thetas zs thetas)
  (define (cons-knot z theta aknot)
    (let ((pn-found (findf (lambda (pn) (equal? z (path-node-z pn))) 
                           (knot-path-nodes aknot)))
          (new-pn (path-node z '() '() '() theta '() '() '())))
      (if pn-found
          (knot (changef (knot-knot-nodes aknot) 
                         (lambda (kn) (equal? z (knot-node-z kn)))
                         (knot-node z pn-found new-pn))
                (cons new-pn (knot-path-nodes aknot)))
          (knot (cons (knot-node z new-pn '()) (knot-knot-nodes aknot))
                (cons new-pn (knot-path-nodes aknot))))))

  (define (make-knot points thetas)
    (if (null? points)
        (knot '() '())
        (cons-knot (car points) (car thetas) 
                   (make-knot (cdr points) (cdr thetas)))))
  
  (define (knot-node-tweak-thetas kn)
    (let* ((pn1 (knot-node-first-path-node kn))
           (pn2 (knot-node-second-path-node kn))
           (tweak (tweak-angles (path-node-angle pn1) (path-node-angle pn2)))
           (z (knot-node-z kn)))
      (knot-node z
                 (path-node z (+ (path-node-theta pn1) tweak))
                 (path-node z (- (path-node-theta pn2) tweak)))))
  
  (let* ((orig-k (make-knot zs thetas))
        (k-nodes (map knot-node-tweak-thetas (knot-knot-nodes orig-k))))
    (list orig-k k-nodes)))
        
       
         

(define (make-cycle . points)
  (define (aux points path knot-nodes)
    (if (null? points)
        (list (reverse path) knot-nodes)
        (let* ((z (car points))
               (pn-found (findf (lambda (pn) (equal? z (path-node-z pn))) path))
               (new-pn  (path-node z '() '() '() '() '() '() '())))
          (aux (cdr points)
               (cons new-pn path)
               (if pn-found 
                   (cons (knot-node z pn-found new-pn) knot-nodes)
                   knot-nodes)))))
  (aux points '() '()))


;(define z1 (knot-node 100+200i '() '()))
;(define z2 (knot-node 200+100i '() '()))
;(define z3 (knot-node 200+300i '() '()))
;(define z4 (knot-node 300+200i '() '()))
;(define z5 (knot-node 400+100i '() '()))
;(define z6 (knot-node 400+300i '() '()))
;(define z7 (knot-node 500+200i '() '()))
;
;(define knot-nodes (list z1 z2 z3 z4 z5 z6 z7))
;
;(define cycle
;  (make-cycle z1 z2 z5 z7 z6 z4 z2 z1 z3 z6 z7 z5 z4 z3))

(define   z1 100+200i )
(define  z2 300+200i )
(define  z3  200+300i)
(define  z4  200+400i )


(match-define (list cycle knot-nodes) (make-cycle z1 z2 z3 z4 z2 z1 z4 z3))



(define (fill-up-chords cycle)
  (let ((chords (map (lambda (pn1 pn2) (- (path-node-z pn2) (path-node-z pn1)))
                     cycle
                     (cycle-left-1 cycle))))
    (map set-path-node-chord-right! cycle chords)
    (map set-path-node-chord-left! cycle (cycle-right-1 chords))))

(fill-up-chords cycle)
(map (lambda (pn)
       (set-path-node-psi! 
        pn
        (angle (/ (path-node-chord-right pn) (path-node-chord-left pn)))))
     cycle)

(define knots (map path-node-z cycle))

(define n (length knots))
(define deltas (cycle-map-minus knots))
(define psis
  (map (lambda (d-k-1-k d-k-k+1) (angle (/ d-k-k+1 d-k-1-k)))
       (cycle-right-1 deltas)
       deltas))
(define (fmod x r)
  (- x (* (round (/ x r)) r)))
(define (mod-angle a)
  (- a (* (round (/ a (* 2 pi))) (* 2 pi))))


;mf116
(define (velocity theta phi)
  (let ((ct (cos theta))
        (st (sin theta))
        (cf (cos phi))
        (sf (sin phi))
        (rt5 (sqrt 5)))
    (min 4.0
         (/ (+ 2.0
               (* (sqrt 2) 
                  (- st (/ sf 16)) 
                  (- sf (/ st 16)) 
                  (- ct cf)))
            (+ 1 
               (* 0.5 (- rt5 1) ct)
               (* 0.5 (- 3 rt5) cf))))))

(define (prev i)
  (modulo (sub1 i) n))
(define (next i)
  (modulo (add1 i) n))

;mf276
(define (A i j)
  (if (not (eq? j (prev i)))
      0
      (/ 1 (magnitude (list-ref deltas j)))))
(define (B+C i j)
  (if (not (eq? i j))
      0
      (+ (/ 2 (magnitude (list-ref deltas (prev i))))
         (/ 2 (magnitude (list-ref deltas i))))))
(define (D i j)
  (if (not (eq? j (next i)))
      0
      (/ 1 (magnitude (list-ref deltas i)))))

(define right
  (build-matrix 
   n 1
   (lambda (i j) 
     (- 0
        (* (/ 2 (magnitude (list-ref deltas (prev i)))) 
           (list-ref psis i))
        (* (/ 1 (magnitude (list-ref deltas i))) 
           (list-ref psis (next i)))))))

(define mat
  (build-matrix n n
                (lambda (i j) (+ (A i j) (B+C i j) (D i j)))))

(define thetas
  (matrix->list (matrix-solve mat right)))

(map set-path-node-theta! cycle thetas)

; modify thetas, so that the curve intersects itself orthogonaly at each point,
; keeping the same bisector
(define (tweak-angles angle1 angle2)
  (let* ((offset (- angle2 angle1))
         (target-offset (+ (/ pi 2) (* (floor (/ offset pi)) pi))))
    (/ (- offset target-offset) 2)))

(check-equal?
 (+ -1.4 (tweak-angles -1.4 1.4))
 (- (/ pi 4)))

(check-equal?
 (+ -1.450515964828205 (tweak-angles -1.450515964828205 1.450515964828205))
 (- (/ pi 4)))

(check-equal?
 (+ 1.4 (tweak-angles 1.4 -1.4))
 (/ pi 4))

(check-equal?
 (< (tweak-angles -0.3345558925337896 3.288158208922769)  0 )
 #true)

(define (knot-node-tweak-thetas kn)
  (let* ((pn1 (knot-node-first-path-node kn))
         (pn2 (knot-node-second-path-node kn))
         (tweak (tweak-angles  (path-node-angle pn1) (path-node-angle pn2))))
    (add-path-node-theta! pn1 (+ tweak))
    (add-path-node-theta! pn2 (- tweak))))

(map knot-node-tweak-thetas knot-nodes)

(set! thetas (map path-node-theta cycle))

(define phis
  (map (lambda (theta psi) (- 0 theta psi))
       thetas
       psis))

(map set-path-node-phi! cycle phis)



(define z-path%
  (class dc-path%
    (define (z-curve-to z1 z2 z3)
      (send this curve-to
            (real-part z1)
            (imag-part z1)
            (real-part z2)
            (imag-part z2)
            (real-part z3)
            (imag-part z3)))
    (define (z-move-to z)
      (send this move-to
            (real-part z)
            (imag-part z)))
    (public z-curve-to)
    (public z-move-to)
    (super-new)))

(define path (new z-path%))

(send path z-move-to (car knots))


;(define (right-control-point index)
;  (let* ((theta (list-ref thetas index))
;         (phi (list-ref phis (next index)))
;         (rr (/ (velocity theta phi) 3))
;         (st (sin theta))
;         (sf (sin phi)))
;    (+ (list-ref knots index)
;       (* (list-ref deltas index)
;          (make-polar 1 theta)
;          rr))))
;
;(define (left-control-point index)
;  (let* ((theta (list-ref thetas (prev index)))
;         (phi (list-ref phis index))
;         (ss (/ (velocity phi theta) 3))
;         (st (sin theta))
;         (sf (sin phi)))
;    (- (list-ref knots index)
;       (* (list-ref deltas (prev index))
;          (make-polar 1 (- phi))
;          ss))))

(for ([i (range n)])
  (send path z-curve-to
        (right-control-point (list-ref knots i) (list-ref deltas i) (list-ref thetas i) (list-ref phis (next i)))
        (left-control-point (list-ref knots (next i)) (list-ref deltas i) (list-ref thetas i) (list-ref phis (next i)))
        (list-ref knots (next i))))

(define frame (new frame%
                   [label "Example"]
                   [width 500]
                   [height 500]))
(define canvas
  (new canvas% [parent frame]
       [paint-callback
        (lambda (canvas dc)
          (send dc draw-path path))]))

(define (get-path-node kn angle)
  (let* ((pn1 (knot-node-first-path-node kn))
	 (theta1 (path-node-theta pn1))
	 (pn2 (knot-node-second-path-node kn))
	 (theta2 (path-node-theta pn2)))
    (if (< (abs (cos (- angle theta1)))
	   (abs (cos (- angle theta2))))
	pn2
	pn1)))

	     

(define (minf l f)
  (define (aux l f val res)
    (if (null? l)
	res
	(let ((valcar (f (car l))))
	  (if (< val valcar)
	      (aux (cdr l) f val res)
	      (aux (cdr l) f valcar (car l))))))
  (aux l f +inf.0 '()))

(define (get-nearest-node x y)
  (minf knots 
	(lambda (z) (magnitude (- z (make-rectangular x y))))))

(define kg-canvas%
  (class canvas%
     (super-new)
     (field [x 0]
            [y 0]
            [node '()])
     (define/override (on-event event)
       (let ((event-type (send event get-event-type)))
	 (case event-type
	   ('left-down (set! x (send event get-x))
		       (set! y (send event get-y))
		       (set! node (get-nearest-node x y)))
	   ('left-up
	    (let ((mouse-z (make-rectangular
			    (send event get-x)
			    (send event get-y))))
	      (when (equal? node 
			    (get-nearest-node 
			     (send event get-x)
			     (send event get-y)))
		    (get-path-node node 
				   (angle (- mouse-z
					     (make-rectangular x y))))))))))))

